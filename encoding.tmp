	cf0 := (X X !a2 | X !a1);
	cf := (cf0);
	sd1 := (X a1);
	sd2 := (X X a2 -> (() & ));
	self_defending := (sd1 & sd2);
	adm := cf & self_defending;
	e1 := (X a1 -> G (send -> X a1));
	e2 := (X X a2 -> G (send -> X X a2));
	expand := e1 & e2;
	g1 := (X !a1 -> F (send & X a1));
	g2 := (X X !a2 -> F (send & X X a2));
	expand_str := g1 & g2;
	h1 := (X !a1 & X X !a2) -> F (send & (X a1 & X X !a2)) & F (send & (X !a1 & X X a2)) & F (send & (X a1 & X X a2));
	all_inner := h1 & h2;
	all_ex_path := G (send -> all_inner);
	ex_non_add(ai) := (X X X G (send -> !adm));
	formula := (adm & expand & expand_str & all_ex_path & ex_non_add) -> X a1;

MODULE main
VAR
		a1	: boolean;
		a2	: boolean;
		state	: {v1,v2,f1,f2,send};

ASSIGN
	init(state) := send;

	next(state) := case
		state = v1 | state = f1 :	{v2,f2};
		state = v2 | state = f2 :	send;
		state = send : {v1,f1};
esac;

	init(a1) := FALSE;
	init(a2) := FALSE;

	next(ai) := case // 1 <= i <= n
		next(state) = vi : TRUE;
		TRUE : FALSE;
esac;

LTLSPEC <>